### Redis基本数据类型

#### SDS 简单动态字符串

Redis只会使用C字符串作为字面量，在大多数情况下，Redis使用SDS作为字符串表示。

##### 相对C字符串的优点

1. 常数复杂度获取字符串长度
2. 杜绝缓冲区溢出
3. 减少修改字符串长度时所需的内存分配次数
4. 二进制安全
5. 兼容部分C字符串函数

#### 链表

1. 每个链表结点由一个listNode结构来表示，每个节点都有一个指向前置节点和后置节点的指针，所以Redis的链表实现是双端链表。
2. 每个链表使用一个list结构来表示，这个结构带有表头结点指针，表尾节点指针，以及链表长度等信息。
3. 因为链表表头结点的前置结点和表尾结点的后置结点都指向NULL，所以Redis的链表实现是无环链表。
4. 通过为链表设置不同的类型的特定函数，Redis的链表可以用于保存各种不同类型的值。

#### 字典

Redis的字典使用哈希表作为底层实现，一个哈希表里面可以有多个哈希表节点，而每个哈希表结点就保存了字典中的一个键值对。

Redis使用MurmurHash2算法来计算键的哈希值。

##### 字典结构

```c
typedef struct dict{
  dictType *type;
  void *privdata;//私有数据
  dictht ht[2];
  //rehash索引
  //当rehash不在进行时，值为-1
  int rehashidx;
};
```

###### ht

ht属性是一个包含两个项的数组，数组中的每一个项都是一个dictht哈希表，一半情况下，字典只使用ht[0]哈希表，ht[1]哈希表只会在对ht[0]哈希表进行rehash时使用。

###### rehashidx

记录了rehash目前的进度。如果没有在进行rehash，那么它的值为-1

###### rehash

为了让哈希表的负载因子维持在一个合理的范围之内，当哈希表保存的键值对数量太多或者太少时，程序需要怼哈希表的大小进行相应的扩展或者收缩。

##### 哈希表的扩展与收缩

当以下条件中的任意一个被满足时，程序会自动开始对哈希表执行扩展操作。

1. 服务器目前没有在执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于1。
2. 服务器目前正在执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于5.
3. 当哈希表的负载因子小于0.1时，程序自动开始对哈希表执行收缩操作。

执行BGSAVE或者BGREWRITEAOF命令的过程中，Redis会创建子进程，会进行写时拷贝。提高指向扩展操作所需要的负载因子，从而尽可能避免在子进程存在期间进行哈希表扩展操作，这可以避免不必要的内存写入操作，最大限度地节约内存。

##### 渐进式rehash

1. 为ht[1]分配空间，让字典同时持有ht[0]和ht[1]两个哈希表。
2. 在字典中维持一个索引计数器变量rehashidx，并将它的值设置为0，表示rehash工作正式开始。
3. 在rehash进行期间，每次都字典进行添加，删除，查找或者更新操作时，程序除了执行指定的操作以外，还会顺带将ht[0]哈希表在rehashidx索引上的所有键值对rehash到ht[1]上，当rehash工作完成之后，程序将rehashidx属性值增1。
4. 随着字典的操作不断执行，最终在某个时间点上，ht[0]的所有键值对都会被rehash到ht[1]上，这时候把rehashidx设置为-1，表示rehash操作已完成。

##### 渐进式rehash执行期间的哈希表操作

先查ht[0],如果没有找到的话，再去查找ht[1]。另外渐进式rehash期间，新添加到字典里面的键值对一律会被保存到ht[1]里面。

#### 跳跃表

##### redis对跳跃表的应用

1. 实现有序集合的键
2. 集群节点中用作内部数据结构


###### 后退指针

节点的后退指针用于从表尾向表头方向访问节点：跟可以一次跳过多个节点的前进指针不同，因为每个结点只有一个后退指针，所以每次只能后退至前一个结点。

###### 分值相同的节点的排序按照成员对象在字典序中的大小来进行排序。

###### 跳跃表头结点成员

1. header 指向跳跃表的表头
2. tail 指向跳跃表的表尾结点
3. length 记录节点的数量，程序可以在O(1)复杂度内返回跳跃表的长度
4. level 在O（1）复杂度内获取跳跃表中层高最大的那个节点的层数量。


#### 整数集合

整数集合是集合键的底层实现之一，当一个集合中只包含整数值元素，并且这个集合的元素数量不多的时候，Redis就会使用整数集合作为集合键的底层实现。

##### intset结构

1. encoding : INTSET_ENC_INT16,INTSET_ENC_INT32,INTSET_ENC_INT64
2. length
3. contents

##### 升级

升级整数集合并添加新元素共分为三步进行：

1. 根据新元素的类型，扩展整数集合底层数组的空间大小，并为新元素分配空间
2. 将底层数组现有的所有元素都转换成与新元素相同的类型，并将类型转换后的元素放置到正确的位上，而且在放置元素的过程中，需要继续维持底层数组的有序性质不变。
3. 将新元素添加到底层数组中。

###### 升级的好处

1. 提升整数集合的灵活性
2. 尽可能地节约内存

##### 降级

整数集合不支持降级操作，一旦对数组进行了升级，编码就会一直保持升级后的状态。

#### 压缩列表

压缩列表是列表键和哈希键的底层实现之一。当一个列表键只包含少量列表项，并且每个列表项要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做列表键的底层实现。

##### 压缩列表的结构

|         |        |       |        |        |                   |
| ------- | ------ | ----- | ------ | ------ | ----------------- |
| zlbytes | zltail | zllen | entry1 | entry2 | zlend(0xFF)用于标记末端 |

##### 压缩列表节点的构成

|                       |          |         |
| --------------------- | -------- | ------- |
| previous_entry_length | encoding | content |

1. previous_entry_length 1字节或者5字节，长度小于254字节，为1字节.大于等于254字节，长度为5字节，属性的第一字节设置为0xFE.(**程序可以通过指针运算，根据当前节点的起始地址来计算出前一个节点的起始地址。**)

##### 连锁更新

添加节点和删除节点都可能会引发连锁更新

#### 对象

###### 类型

对于Redis数据库保存的键值对来说，键总是一个字符串对象，而值则可以是字符串对象，列表对象，哈希对象，集合对象或者有序集合对象的其中一种。因此：

1. 当我们称呼一个数据库键为“字符串键”时，我们指的是“这个数据库键对应的值为字符串对象”；
2. 当我们称呼一个键为“列表键”时，我们指的是"这个数据库键所对应的值为列表对象"。
3. TYPE命令的实现方式也与此类似，当我们对一个数据库键执行TYPE命令时，命令返回的结果为数据库键对应的值对象的类型，而不是键对象的类型。

##### 字符串对象

字符串对象的编码可以是int，raw或者embstr。

1. 字符串长度小于等于32字节，使用embstr编码；
2. 字符串长度大于32字节，使用sds编码；
3. long double类型表示的浮点数在Redis中也是作为字符串值来保存的。
4. embstr只用进行一次内存分配和释放，sds需要进行2次内存分配和释放。embstr只读，如果对其进行任何修改，编码会转换成sds编码。

##### 列表对象

列表对象的编码可以是ziplist或者linkedlist

###### 编码转换

当列表对象可以同时满足以下两个条件时，列表对象使用ziplist编码：

1. 列表对象保存的所有字符串元素的长度都小于64字节
2. 列表对象保存的元素数量小于512个；不能满足这两个条件的列表对象需要使用linkedlist编码。

##### 哈希对象

哈希对象的编码可以是ziplist或者hashtable.

ziplist编码的哈希对象使用压缩列表作为底层实现，每当有新的键值对要加入到哈希对象时，程序会先将保存了键的压缩列表节点推入到压缩列表表尾，然后再将保存了值的压缩列表节点推入到压缩列表表尾。因此：

1. 保存了同一个键值对的两个节点总是紧挨在一起，保存键的节点在前，保存值的节点在后；
2. 先添加到哈希对象中的键值对会被放在压缩列表的表头方向，而后来添加到哈希对象中的键值对会被放在压缩列表的表尾方向。

###### 编码转换

当列表对象可以同时满足以下两个条件时，哈希对象使用ziplist编码：

1. 哈希对象保存的所有键和值的字符串的长度都小于64字节;
2. 哈希对象保存的元素数量小于512个；不能满足这两个条件的列表对象需要使用hashtable编码。

##### 集合对象

集合对象的编码可以intset或者hashtable。

###### 编码转换的条件

1. 集合对象保存的所有元素都是整数值；
2. 集合对象保存的元素数量不超过512个。

不能满足这两个条件的集合对象需要使用hashtable编码。

##### 有序集合对象

有序集合对象的编码可以是ziplist或者skiplist

每个集合元素使用两个紧挨在一起的压缩列表节点来保存，第一个节点保存元素的成员，而第二个元素则保存元素的分值。压缩列表内的集合元素按照分值从小到大进行排序，分值较小的元素被放置在靠近表头的方向，分值较大的元素则被放置在靠近表尾的方向。

除此之外zset结构中的dict字典为有序集合创建了一个从成员到分值的映射。

###### 编码转换的条件

1. 有序集合保存的元素数量小于128个；
2. 有序集合所有元素成员的长度都小于64字节。

不能满足这两个条件的集合对象需要使用skiplist编码。

### 单机数据库的实现

#### Redis持久化

##### 快照持久化

###### save和bgsave

1. SAVE会阻塞REDIS服务器进程，直到快照创建完毕，阻塞期间，服务器进程不能处理任何命令请求
2. BGSAVE会创建一个子进程来负责创建快照，主进程继续处理命令请求
3. 执行bgsave期间拒绝其他的save和bgsave命令，防止产生竞态条件
4. bgsave和bgrewriteaof也不能同时执行，从性能方面考虑，都要执行大量的磁盘写入操作。

###### dirty计数器和lastsave

###### 如果开启了AOF持久化功能，优先用AOF文件还原数据库状态

AOF文件的更新频率通常比RDB文件的更新频率高。

##### AOF持久化

命令追加，文件写入，文件同步

1. 命令追加，写到AOF缓冲区
2. 文件写入
3. 文件同步

###### appendfsync

| 选项       | 同步频率                             |
| -------- | -------------------------------- |
| always   | 每个redis写命令都要同步写入硬盘。这样会降低Redis的速度 |
| everysec | 每执行一次同步，显式地将多个写命令同步到硬盘           |
| no       | 让操作系统来决定何时进行同步                   |

###### 体积不断增大的AOF文件甚至可能会用完硬盘的所有可用空间。所以需要重写AOF文件

###### BGREWRITEAOF

这个命令会通过移除AOF文件中的冗余命令来重写AOF文件，使AOF文件的体积变得尽可能地小。

#### Redis复制的启动过程

##### 从服务器连接主服务器时的步骤

|  步骤  | 主服务器操作                                   | 从服务器操作                                   |
| :--: | ---------------------------------------- | ---------------------------------------- |
|  1   | 等待命令进入                                   | 连接(或者重连接)主服务器，发送sync命令                   |
|  2   | 开始执行BGSAVE,并使用缓冲区记录BGSAVE之后指向的所有写命令      | 根据配置选项来决定是继续使用现有的数据来处理客户端的命令请求，还是向发送请求的客户端返回错误 |
|  3   | BGSAVE执行完毕之后，向从服务器发送快照文件，并在发送期间继续使用缓冲区记录被执行的写命令 | 丢弃所有旧数据，开始载入主服务器发来的快照文件                  |
|  4   | 快照文件发送完毕，开始向从服务器发送存储在缓冲区里面的写命令           | 完成对快照文件的解释操作，像往常一样开始接受命令请求               |
|  5   | 缓冲区存储的写命令发送完毕，从现在开始，每执行一个写命令，就向从服务器发送相同的写命令 | 执行主服务器发来的所有存储在缓冲区里面的写命令；并从现在开始，接收并执行主服务器传来的每个写命令 |

##### 主从链

从服务器对从服务器进行复制在操作上和从服务器对主服务器进行复制的唯一区别在于，如果从服务器X拥有从服务器Y,那么当从服务器X在执行步骤4时，它将断开与从服务器Y的连接，导致从服务器Y需要重新连接并重新同步。

###### 如何缓解主服务器无法快速地更新所有从服务器，或者因为重新连接和重新同步从服务器而导致系统超载

用户可以创建一个Redis主从节点组成的中间层来分担服务器的复制工作。

###### 检验硬盘写入

1. 验证主服务器是否已经将写数据发送至从服务器，在写入真正的数据之后，再向主服务器写入一个唯一的虚构值，然后通过检查虚构值是否存在于从服务器来判断写数据是否已经到达从服务器。
2. 判断数据是否已经保存在硬盘，检查INFO命令的输出结果中的aof_pending_bio_fsync属性的值是否为0，如果为0的话，那么就表示服务器已经将已知的所有数据都保存到硬盘里面了。

###### 验证快照文件和AOF文件

1. 程序修复AOF文件的方法非常简单，它会扫描给定的AOF文件，寻找不正确或者不完整的命令，当发现第一个出错命令的时候，程序会删除出错的命令以及位于出错命令之后的所有命令，只保留那些位于出错命令之前的正确命令。
2. 通过计算快照文件的SHA1散列值和SHA256散列值来对内容进行验证。

###### 更换故障主服务器

假设A,B两台机器都运行着Redis，其中机器A的Redis为主,B为从，不巧A机器发生故障暂时无法修改。

1. 用一个机器C用作新的主服务器。更换服务器的计划非常简单，首先向机器B发送一个SAVE命令，让它创建一个新的快照文件，接着将这个快照文件发送给机器C，并在机器C上面启动Redis。最后让机器B成为C的从服务器。
2. 将从服务器升级为主服务器，并为升级之后的主服务器创建从服务器。

### 多机数据库的实现

#### 主从复制

#### Sentinel 哨兵服务器

##### 监视服务器和每一个mater服务器之间会建立一个命令连接和订阅连接

监视服务器通过命令连接发送info命令询问master的信息。通过订阅连接通告master进程自己的信息。

监视服务器通过每秒发送一次ping命令询问master是否已经下线。区域内监视同一个master服务器的监视服务器会建立命令连接。当监视服务器通过ping命令返回无效命令超时之后主观认为master服务器下线之后，会向区域内的其他监视服务器询问。如果认为master服务器下线的监视服务器数量达到阈值，则认为master服务器客观下线。

##### 选取领头羊

每一个sentinel要求区域内的其他sentinel把自己设置为自己的区域领头羊，先来先得。然后是半数以上sentinel的区域领头羊设置为总领头羊。若没有选出，则重新选举。

##### 如何选出新的主服务器

优先级最高，复制偏移量最大，运行ID最小的从服务器提升为主服务器。

#### 集群

握手->响应握手->添加到集群，CLUSTER MEETING

