#### 命令行如何连接mysql

```bash
mysql -h127.0.0.1 -uroot -p123456
```

### MySQL架构与历史

#### 什么是数据库存储引擎？

##### InnoDB/XtraDB

Mysql最重要,最与众不同的特性是它的存储引擎架构，这种架构的设计将查询处理及其他系统任务和数据的存储/提取相分离。这种处理和存储分离的设计可以在使用时根据性能，特性，以及其他需求来选择暑假存储的方式。

##### MyISAM与InnoDB区别

两种类型最主要的差别就是InnoDB支持事务处理与外键和行级锁。

#### 锁粒度（锁住的范围）

一种提高共享资源并发性的方式就是让锁定对象更有选择性。尽量只锁定需要修改的部分数据，而不是所有的资源。更理想的方式是，只对会修改的数据片进行精确的锁定。任何时候，在给定的资源上，锁定的数据量越少，则系统的并发程度越高，只要相互之间不发生冲突即可。

##### mysql则提供了多种选择。每种mysql存储引擎都可以实现自己的锁策略和锁粒度。

#### 两种最重要的锁策略

##### 表锁

###### 表锁是MYSQL中最基本的锁策略，并且是开销最小的策略。表锁会锁定整张表。

写锁也比读锁有更高的优先级，因此一个写锁请求可能会被插入到读锁队列的前面。

尽管存储引擎可以管理自己的锁，mysql本身还是会使用各种有效的表锁来实现不同的目的。例如，服务器会为诸如ALTER TABLE之类的语句使用表锁，而忽略存储引擎的锁机制。

##### 行级锁

###### 行级锁可以最大程度地支持并发处理（同时也带来了最大的锁开销）。

众所周知，在InnoDB和XtraDB，以及其他一些存储引擎中实现了行级锁。行级锁只在存储引擎层实现，而mysql服务器层没有实现。服务器层完全不了解存储引擎中的锁实现。

#### 事务

ACID

##### 原子性

事务内的语句，要么全部执行成功，要么全部执行失败。

##### 一致性

事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。

一致写：事务执行的数据变更只能基于上一个一致的状态，且只能体现在一个状态中。T(n)的变更结果只能基于C(n-1)，C(n-2), ...C(1)状态，且只能体现在C(n)状态中。也就是说，一个状态只能有一个事务变更数据，不允许有2个或者2个以上事务在一个状态中变更数据。至于具体一致写基于哪个状态，需要判断T(n)事务是否和T(n-1)，T(n-2),...T(1)有依赖关系。

一致读：事务读取数据只能从一个状态中读取，不能从2个或者2个以上状态读取。也就是T(n)只能从C(n-1），C(n-2)... C(1)中的一个状态读取数据，不能一部分数据读取自C(n-1)，而另一部分数据读取自C(n-2)。

##### 隔离性

通常来说，一个事务所做的修改在最终提交以前，对其他事务是不可见的。

##### 持久性

一旦事务提交，则其所做的修改就会永久保存到数据库中。

#### 隔离级别

##### READ UNCOMMITED（未提交读）

在Read Uncommit级别，事务中的修改，即使没有提交，对其他事务也都是可见的。事物可以读取未提交的数据，这也被称为脏读。

##### READ COMMIT（提交读）

大多数数据库系统的默认隔离级别都是READ COMMITED（但MYSQL不是）。READ COMMITED满足前面提到的隔离性的简单定义：一个事务开始时，只能看见已经提交的事务所做的修改。

###### 这个级别有时候叫做不可重复读，因为两次执行同样的查询，可能会得到不一样的结果。

##### REPEATABLE READ（可重复读）

 REPEATABLE READ解决了脏读的问题。该级别保证了在同一个事务中多次读取同样的记录的结果是一致的。但是理论上，可重复读隔离级别还是无法解决另外一个幻读的问题。

###### 所谓幻读，指的是当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行。

###### 可重复读是mysql是默认事务隔离级别。

##### SERIALIZABLE(可串行化)

SERIALIZABLE是最高的隔离级别。它通过强制事务串行执行，避免了前面说的幻读的问题。SERIALIZABLE会在读取的每一行数据上都加锁，所以可能导致大量的超时和锁争用的问题。

##### ANSI SQL隔离级别

| 隔离级别            | 脏读可能性 | 不可重复读可能性 | 幻读可能性 | 加锁读  |
| --------------- | ----- | -------- | ----- | ---- |
| READ UNCOMMITED | YES   | YES      | YES   | NO   |
| READ COMMITED   | NO    | YES      | YES   | NO   |
| REPEATABLE      | NO    | NO       | YES   | NO   |
| SERIALIZABLE    | NO    | NO       | NO    | YES  |

#### 死锁

##### InnoDB目前处理死锁的方法是，将持有最少行级排他锁的事务进行回滚（这是相对比较简单的死锁回滚算法）。

###### 锁的行为和顺序是和存储引擎相关的。以同样的顺序执行语句，有些存储引擎会产生死锁，有些则不会。死锁的产生又双重原因：有些是因为真正的数据冲突，这种情况通常很难避免，蛋有些则完全是由于存储引擎的实现方式导致的。

###### 死锁发生以后，只有部分或完全回滚其中的一个事务，才能打破死锁。

#### 事务日志

事务日志可以帮助提高事物的效率。使用事务日志，存储引擎在修改表的数据时只需要修改其内存拷贝，再把该修改行为记录到持久在硬盘上的事物日志中，而不用每次都将修改的数据本身持久到磁盘。事务日志采用的是追加的方式，因此写日志的操作是磁盘上一小块区域内的顺序I/O,而不是像随机I/0需要在磁盘的多个地方移动磁头，所以采用事务日志的方式相对来说快的多。事务日志持久以后，内存中的被修改的数据在后台可以慢慢地刷回到磁盘。目前大多数存储引擎都是这样实现的。我们通常称之为预写式日志，修改数据需要写两次磁盘。

#### 隐式和显式锁定

InnoDB采用的是两阶段锁定协议。在事务执行过程中，随时都可以执行锁定，锁只有在执行COMMIT或者ROLLBACK的时候才会释放，并且所有的锁是在同一时刻被释放。前面描述的锁定都是隐式锁定，InnoDB会根据隔离级别在需要的时候自动加锁。

##### MVCC(多版本并发控制)

下面我们通过InnoDB的简化版行为来说明MVCC是如何工作的。

##### InnoDB的MVCC，是通过在每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存了行的过期时间（或删除时间）。当然存储的不是实际的时间值，而是系统版本号。每开始一个新的事务，系统版本号都会自动递增。事物开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。

下面看一下在REPEATABLE READ隔离级别下，MVCC具体是如何操作的。

###### SELECT

1. InnoDB只查找版本早于当前事务版本的数据行（也就是，行的系统版本号小于或等于事务的系统版本号），这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的。
2. 行的删除版本要么没有定义，要么大于当前事务版本号。这可以确保事务读取到的行， 在事物开始之前未被删除。

只有符合上述两个条件的记录，才能返回作为查询的结果。

###### INSERT

InnoDB为新插入的每一行保存当前系统版本号作为行版本号。

###### DELETE

InnoDB为删除的每一行保存当前系统版本号作为行删除标识。

###### UPDATE

InnoDB为插入一行新记录，保存当前系统版本号作为行版本号。同时保存当前系统版本号到原来的行作为删除标识。

##### 保存这两个额外的系统版本号，使大多数读操作都可以不用加锁。这样的设计使得读操作很简单。性能很好，并且也能保证只会读取到符合标准的行。不足之处是每行记录都需要额外的存储空间，需要做更多的行检查工作，以及一些额外的维护工作。

##### InnoDB存储引擎

InnoDB存储是MySQL的默认事务型引擎，也是最重要，使用最广泛的存储引擎。它被设计用来处理大量的短期事务，短期事务大部分情况是正常提交的，很少会被回滚。InnoDB的性能和自动崩溃恢复特性，使得它在非事务型存储的需求中也很流行。

##### InnoDB概览

InnoDB的数据存储在表空间中，表空间是由InnoDB管理的一个黑盒子，由一系列的数据文件组成。在mysql 4.1i以后的版本中，InnoDB可以将每个表的数据和索引存放在单独的文件中。

InnoDB采用MVCC来支持高并发，并且实现了四个标准的隔离级别。其默认级别是可重复读，并且通过间隙锁策略防止幻读的出现。间隙锁使得InnoDB不仅仅锁定查询涉及的行，还会对索引中的间隙进行锁定，以防止幻影行的插入。

InnoDB表是基于聚簇索引建立的。InnoDB的索引结构和MySQL的其他存储引擎有很大的不同，聚簇索引对主键查询又很高的性能。不过他的二级索引（非主键索引）中必须包含主键列，所以如果主键列很大的话，其他的所有索引都会很大。因此，若表上的索引较多的话，主键应当尽可能的小。

InnoDB内部做了很多优化，包括从磁盘读取数据时采用的可预测性读，能够自动在内存中创建hash索引以加速读操作的自适应哈希索引，以及能够加速插入操作的插入缓冲区等。

作为事务型的存储引擎，InnoDB通过一些机制和工具支持真正的热备份。MySQL的其他存储引擎不支持热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能意味着停止读取。

##### MyISAM存储引擎

在MySQL5.1及之前的版本，MyISAM是默认的存储引擎。MyISAM提供了大量的特性，包括全文索引,压缩，空间函数等，但MyISAM不支持事务和行级锁，而且有一个毫无疑问的缺陷就是崩溃后无法安全恢复。

###### MyISAM也支持全文索引，这是一种基于分词创建的索引，可以支持复杂的查询。

##### CD-ROM应用

如果要发布一个基于CD-ROM或者DVD-ROM并且使用MySQL数据文件的应用，可以考虑使用MyISAM表或者MyISAM压缩表，这样表之间可以隔离并且可以在不同介质上相互拷贝。MyISAM压缩表比未压缩的表要节约很多空间，但压缩表是只读的。

##### 转换表的引擎

###### ALTER TABLE

下面的语句将mytable的引擎修改为InnoDB;

```mysql
ALTER TABLE mytable ENGINE = InnoDB;
```

上述语法可以适用任何存储引擎。但有一个问题：需要执行很长时间。M有SQL会执行将数据从原表复制到一张新的表中，在复制期间可能会消耗系统所有的I/O能力，同时原表上会加上新锁。

如果转换表的存储引擎，将会失去和原引擎相关的所有特性。例如将一张InnoDB表转换为MyISAM,然后再转换回InnoDB,原InnoDB表上的所有的外键将丢失。

### Schema与数据类型优化

#### 选择优化的数据类型

MySQL支持的数据类型非常多，选择正确的数据类型对于获得高性能至关重要。

##### 更小的通常更好

一般情况下，应该尽量使用可以正确存储数据的最小数据类型。更小的数据类型。更小的数据类型通常更快，因为它们占用更小的磁盘，内存和CPU缓存，并且处理时需要的CPU周期也更少。

##### 简单就好

简单数据类型的操作通常需要更少的CPU周期。例如，整型比字符操作代价更低。因为字符集和校对规则使字符比较比整型比较更复杂。这里又两个例子：一个是应该使用MySQL内建的类型而不是字符串来存储日期和时间，另外一个是应该用整型存储IP地址。

##### 尽量避免NULL

很多表都包含可为NULL（空值）的列，即使应用程序并不需要保存NULL也是如此，这是因为可为NULL是列的默认属性。通常情况下最好指定列为NOT NULL，除非真的需要存储NULL值。

如果查询中包含可为NULL的列，对MySQL来说更难优化，因为可为NULL的列使得索引，索引统计和值比较都更复杂。可为NULL的列会使用更多的存储空间，在MySQL里也需要特殊处理。

通常把可为NULL的列改为NOT NULL带来的性能提升比较小，所以（调优时）没有必要首先在现有schema中查找并修改掉这种情况，除非确定这会导致问题。但是，如果计划在列上建索引，就应该避免设计成可为NULL的列。

当然也有例外，例如值得一提的是，InnoDB使用单独的位（bit）存储NULL值，所以对于稀疏数据有很好的空间效率。

###### 在为列选择数据类型时，第一步需要确定合适的大类型:数字，字符串，时间等。

例如，DATETIME和TIMESTAMP列都可以存储相同类型的数据：时间和日期，精确到秒。然而TIMESTAMP只使用DATETIME一半的存储空间，并且会根据时区变化，具有特殊的自动更新能力。另一方面，TIMESTAMP允许的时间范围要小得多，有时候它的特殊能力会成为障碍。

##### 整型类型

TINYINT,SMALLINT,MEDIUMINT,INT,BIGINT。分别使用8，16，24，32，64位存储空间。整型类型有可选的UNSIGNED属性，表示不允许负值，这大致可以使正数的上限提高一倍。

MySQL可以为整数类型 指定宽度，例如INT(11)，怼大多数应用这是没有意义的：它不会限制值的合法范围，只是规定了MySQL的一些交互工具（例如MySQL命令行客户端）用来显示字符的个数。对于存储和计算来说，INT(1)和INT(20)是相同的。

##### 实数类型

实数是带有小数部分的数字。然而，它们不只是为了存储小数部门；也可以使用DECIMAL存储比BIGINT还大的整数。MySQL既支持精确类型，也支持不精确类型。

浮点类型在存储同样范围的值时，通常比DECIMAL使用更少的空间。FLOAT使用4个字节存储。DOUBLE占用8个字节，相比FLOAT有更高的精度和更大的范围。和整数类型一样，能选择的只是存储类型；MySQL使用DOUBLE作为内部浮点计算的类型。

##### 字符串类型

MySQL支持多种字符类型，每种类型还有很多变种。从MySQL4.1开始，每个字符串列可以定义自己的字符集和排序规则，或者说校对规则。这些东西会很大程度上影响性能。

###### VARCAHR 和CAHR类型

VARCHAR和CAHR是两种最主要的字符串类型。不幸的是，很难精确地解释这些值是怎么存储在磁盘和内存中的，因为这跟存储引擎的具体实现有关。下面的描述假设使用的存储引擎是InnoDB或者MyISAM。

*VARCHAR*

VARCHAR类型用于存储可变长字符串，是最常见的字符串数据类型。它比定长类型更节省空间，因为它仅仅使用必要的空间。VARCHAR需要使用1或2个额外字节记录字符串的长度：如果列的最大长度小于或等于255字节，则只使用1个字节表示，否则使用2个字节。**下面这些情况下使用VARCHAR是合适的：字符串列的最大长度比平均长度大得多；列的更新很少，所以碎片不是问题；使用了像UTF-8这样复杂的字符集，每个字符都使用不同的字节数进行存储**。在5.0或者更高版本，MySQL在存储和检索时会保留末尾空格。但在4.1或更老的版本，MySQL会剔除末尾空格。 

*CHAR*

CAHR类型是定长的。MYSQL总是根据定义的字符串长度分配足够的空间。当存储CHAR值时，MySQL会删除所有的末尾空格。CHAR值会根据需要采用空格进行填充以方便比较。

CHAR适合存储很短的字符串，或者所有值都接近同一个长度。例如，CAHR非常适合存储密码的MD5值，因为这是一个定长的值。对于经常变更的数据，CAHR也比VARCHAR更好，因为定长的CAHR类型不容易产生碎片。对于非常短的列。CAHR比VARCHAR在存储空间上也更有效率。

###### 慷慨是不明智的

**使用VARCHAR(5)和VARCHAR(200)存储‘hello’的空间开销是一样的。那么使用更短的列有什么优势吗？**

事实证明有很大的优势。更长的列会消耗更多的内存，因为MySQL通常会分配固定大小的内存块来保存内部值。尤其是使用内存临时表进行排序或操作时会特别糟糕。在利用磁盘临时表进行排序时也同样糟糕。所以最好的策略是只分配真正需要的空间。

###### BLOB和TEXT类型

BLOB和TEXT都是为存储很大的数据而设计的字符串数据类型，分别采用二进制和字符方式存储。

与其他类型不同，MySQL把每个BLOB和TEXT值当作一个独立的对象处理。存储引擎在存储时通常会做特殊处理。当BLOB和TEXT值太大时，InnoDB会使用专门的“外部”存储区域来进行存储，此时每个值在行内需要1-4个字节存储一个指针，然后在外部存储区域存储实际的值。

**MySQL不能将BLOB和TEXT列全部长度的字符串进行索引，也不能使用这些索引消除排序。**

##### 使用ENUM代替字符串类型

有时候可以使用枚举列代替常用的字符串类型。枚举列可以把一些不重复的字符串存储成一个预定义的集合。MySQL在存储枚举时非常紧凑，会根据列表值的数量压缩到一个或者两个字节中。

另外一个让人吃惊的地方是，枚举字段是按照内部存储的整数而不是定义的字符串进行排序的。

##### 日期和时间类型

MySQL可以使用许多类型来保存日期和时间值，例如YEAR和DATE。MySQL能存储的最小时间粒度为秒。但是MySQL也可以使用微秒级别的粒度进行临时运算。

###### DATETIME

这个类型能保存大范围的值，从1001年到9999年，精度为秒。它把日期和时间封装到格式为YYYYMMDDHHMMSS的整数中，与时区无关。使用8个字节的存储空间。

###### TIMESTAMP

TIMESTAMP类型保存了从1970年1月1日午夜以来的秒数，它和UNIX时间戳相同。TIMESTAMP只使用4个字节的存储空间，因此它的范围比DATETIME小得多。TIMESTAMP显示的值也依赖于时区。MySQL服务器，操作系统，以及客户端连接都有时区设置。**TIMESTAMP列默认为NOT NULL,这也和其他的数据类型不一样**

**如果在多个时区存储或访问数据，TIMESTAMP和DATETIME的行为将很不一样。前者提供的值与时区有关系，后者则保留文本表示的日期和时间**

##### 位数据类型

###### BIT

可以使用BIT列在一列中存储一个或多个true/false值。BIT(1)定义一个包含单个位的字段，BIT(2)存储2个位，依此类推。BIT列的最大长度是64个位。

BIT列只需要17个位存储（假设没有可为NULL的列），这样MyISAM只使用3个字节就能存储这17个BIT列。其他存储引擎例如Memory和InnoDB,为每个BIT列使用一个足够存储的最小整数类型来存放，所以不能节省存储空间。

mysql把BIT当作字符串，而不是数字类型。当检索BIT(1)的值时，结果是一个包含二进制0或1值的字符串，而不是ASCII码的''0"或"1"。然而，在数字上下文的场景中检索时，结果将是位字符串转换成数字。

**如果想在bit的存储空间中存储一个true/false值，另一个方法是创建一个可以为空的char(0)列。该列可以保存空值（NULL）或者长度为零的字符串(空字符串)**

###### SET

如果需要保存很多true/false值，可以考虑合并这些列到一个set数据类型，它在MySQL内部是以一系列打包的位的集合来表示的。这样就有效的利用了存储空间，并且MySQL有像FIND_IN_SET()和FIELD()这样的函数，方便地在查询中使用。它的主要缺点是改变列的定义的代价较高。

##### 选择标识符

当选择标识列的类型时，不仅仅需要考虑存储类型，还需要考虑MySQL对这种类型怎么执行计算和比较。例如，MySQL在内部使用整数存储ENUM和SET类型，然后在做比较操作时转换为字符串。

一旦选定了一种类型，要确保在所有关联表中都使用同样的类型。类型之间需要精确匹配，包括像UNSIGNED这样的属性。混用不同数据类型可能导致性能问题，即使没有性能影响，在比较操作时隐式类型转换也可能导致很难发现的错误。这种错误可能会很久以后才突然出现，那时候都可能都已经忘了是在比较不同的数据类型了。

###### 整数类型

整数类型通常是标识列最好的选择，因为它们很快并且可以使用AUTO_INCREMENT

###### ENUM和SET类型

对于标识列来说，ENUM和SET类型通常是一个糟糕的选择，尽管对某些只包含固定状态或者类型的静态“定义表”来说可能是没有问题的。ENUM和SET列适合存储固定信息，例如有序的状态,产品类型，人的性别。

###### 字符串类型

如果可能，应该尽量避免使用字符串类型作为标识列，因为他们很消耗空间，并且通常比数字类型慢。尤其是在MyISAM表里使用字符串作为标识列时要特别小心。MyISAM默认对字符串使用压缩索引，这会导致查询慢很多。

##### 特殊类型数据

某些类型的数据并不直接与内置类型一致。

另外一个例子是一个IPV4地址。人们经常使用VARCHAR(15)列来存储IP地址。然而，他们实际上是32位无符号整数，不是字符串。用小数点将地址分为四段的表示方法只是为了让人们阅读容易。所以应该用无符号整数存储IP地址。MySQL提供INET_ATON()和INET_NTOA()函数在这两种表示方法之间转换。

#### MySQL schema设计中的陷阱

##### 太多的列

MySQL的存储引擎API工作时需要在服务器层和存储引擎层之间通过行缓冲格式拷贝数据，然后在服务器层将缓冲内容解码成各个列。从行缓冲中将编码过的列转换成行数据结构的操作代价是非常高的。

##### 太多的关联

如果希望查询执行得快速且并发性好，单个查询最好在12个表以内做关联。

##### 全能的枚举

注意防止过度使用枚举（ENUM）

##### 变相的枚举

枚举（ENUM）列允许在列中存储一组定义值中的单个值，集合(SET)列则允许在列中存储一组定义值中的一个或多个值。

#### 范式和反范式

在范式化的数据库中，每个事实数据会出现并且只出现一次。相反，在反范式化的数据库中，每个事实数据会出现并且只出现一次。相反，在反范式化的数据库中信息是冗余的，可能会存储在多个地方。

##### 范式的优点和缺点

范式化通常能够带来好处：

1. 范式化的更新操作通常比反范式化要快。
2. 当数据较好地范式化时，就只有很少或者没有重复数据，所以只需要修改更少的数据。
3. 范式化的表通常更小，可以更好地放在内存里，所以执行操作会更快。
4. 很少有多余的数据意味着检索列表时更少需要DISTINCT或者GROUP BY语句。

**范式化设计的schema的缺点是通常需要关联。稍微复杂一些的查询语句在符合范式的schema上都可能需要至少一次关联，也许更多。这不但代价昂贵，也可能使一些索引策略无效。例如，范式化可能将列存在不同的表中，而这些列如果在一个表中可以属于同一个索引。**

##### 反范式化的优点和缺点

反范式化的schema因为所有数据都在一张表中，可以很好地避免关联。

如果不需要关联表，则怼大部分查询最差的情况，即使表没有使用索引，是全表扫描。当数据比内存大时这可能比关联要快的多，因为这样避免了随机I/O。

**全表扫描基本上是顺序I/O，但也不是100%，跟引擎的实现有关**

##### 混用范式化和反范式化

最常用的反范式化数据的方法是复制或者缓存，在不同的表中存储相同的特定列。在MySQL5.0和更新版本中，可以使用触发器更新缓存值，这使得实现这样的方案变得更简单。

#### 缓存表和汇总表

有时提升性能的最好方法是在同一张表中保存衍生的冗余数据。然而，有时也需要创建一张完全独立的汇总表或缓存表(特别是为满足检索的需求时)。如果能容许少量的脏数据，这是非常好的方法，但是有时确实没有选择的余地(例如，需要避免复杂，昂贵的实时更新操作)

术语“缓存表”和“汇总表”没有标准的含义。我们用术语“缓存表”来表示存储那些可以比较简单地从schema其他表获取(但是每次获取的速度比较慢)数据的表（例如，逻辑上冗余的数据）。而术语“汇总表”时，则保存的是使用GROUP BY语句聚合数据的表（例如，数据不是逻辑上冗余的）。也有人使用术语“累积表”称呼这些表。

**不严格的计数或通过小范围查询填满间隙的严格计数,都比计算message表的所有行要有效得多。这是建立汇总表的最关键原因**

**缓存表则相反，其对优化搜索和检索查询语句很有效。**

可能会需要很多不同的索引组合来加速各种类型的查询。这些矛盾的需求有时需要创建一张只包含主表中部分列的缓存表。一个有用的技巧是对缓存表使用不同的存储引擎。例如，如果主表使用InnoDB,用MyISAM作为缓存表的引擎将会得到更小的索引占用空间，并且可以做全文搜索。有时甚至想把整个表导出MySQL,插入到专门的搜索系统中获得更高的搜索效率。

**在使用缓存表和汇总表时，必须决定是实时维护数据还是定期重建。哪些更好依赖于应用程序，但是定期重建并不是节省资源，也可以保持表不会有很多碎片，以及有完全顺序组织的索引(这会更加高效)**

当重建汇总表和缓存表时，通常需要保证数据在操作时依然可用。这就需要通过使用“影子表”来实现，“影子表”指的是一张在真实表"背后"创建的表。当完成了建表操作后，可以通过一个原子的操作切换影子表和原表。

##### 计数器表

假设有一个计数器表，只有一行数据，只有一行数据，记录网站的点击次数：

```sql
mysql>create table hit_counter(cnt int unsigned not null) ENGINE=InnoDB;
mysql>update hit_counter set cnt=cnt+1;
```

问题在于，在于任何想要更新这一行的事务来说，这条记录上都有一个全局的互斥锁（mutex），这会使事务只能串行执行。要获得更高的并发更新性能，也可以将计数器保存在多行中，每次随机选择一行进行更新。

```sql
mysql>create table hit_counter(cnt int unsigned not null,
                              slot tinyint unsigned not null primary key,
                              ) ENGINE=InnoDB;
mysql>update hit_counter set cnt=cnt+1 where slot=rand()*100;
--要获得统计结果，需要使用下面这样的聚合查询
mysql>select sum(cnt) from hit_counter;
```

##### 更快的读，更慢的写

为了提升读查询的速度，经常会需要建一些额外索引，增加冗余列，甚至是创建缓存表和汇总表。这些方法会经常增加写查询的负担，也要额外的维护任务，但在设计高性能数据库时，这些都是常见的技巧：虽然写操作变得更慢了，但更显著地提高了读操作的性能。

#### 加快ALTER TABLE操作的速度

MySQL的ALTER TABLE操作的性能对大表来说是个大问题。

MySQL执行大部分修改表的结构的操作的方法是用新的结构创建一个空表，从旧表中查出所有数据插入新表，然后删除旧表。**这样操作可能需要花费很长时间，如果内存不足而表又很大，而且还有很多索引的情况下尤其如此**

**理论上，MySQL可以跳过创建新表的步骤。列的默认值实际上存在表的.frm文件中，所有可以直接修改这个文件而不需要改动表本身。然而MySQL还没有采用这种优化的方法，所有MODIFY COLUMN操作都将导致表重建。**

另外一种方法是通过ALTER COLUMN操作来改变列的默认值

```sql
mysql>ALTER TABLE sakila.film ALTER COLUMN rental_duration SET DEFAULT 5;
```

这个语句会直接修改.frm文件而不涉及表数据。所以，找个操作是非常快的。

##### 快速创建MyISAM索引

为了高效地载入数据到MyISAM表中，有一个常用的技巧是先禁用索引，载入数据，然后重新启用启动索引。

```sql
mysql>alter table test.load_data disable keys;
--load the data
mysql>alter table test.load_data enable keys;
```

这个技巧能够发挥作用，是因为构建索引的工作被延迟到数据完全载入以后，这个时候已经可以通过排序来构建索引了。这样做会快很多，并且使得索引树的碎片更少，更紧凑。

不幸的是，这个办法对唯一索引无效，因为DISABLE KEYS只对非唯一索引有效。MyISAM会在内存中构造唯一索引，并且为载入的每一行检查唯一性。一旦索引的大小超过有效内存的大小，载入操作就会变得越来越慢。

#### 总结

1. 尽量避免过度设计，例如会导致极其复杂查询的schema设计，或者有很多列的表的设计
2. 使用小而简单的合适数据类型，除非真实数据模型中有确切的需要，否则应该尽可能地避免使用NULL值
3. 尽量使用相同的数据类型存储相似或相关的值，尤其是要在关联条件中使用的列
4. 注意可变长字符串，其在临时表和排序时可能导致悲观的按最大长度分配内存
5. 尽量使用整型定义标识列
6. 避免使用MySQL已经遗弃的特性，例如指定浮点数的精度，或者整数的显示宽度
7. 小心使用ENUM和SET。虽然它们用起来很方便，但是不要滥用，否则有时候会变成陷阱，最好避免使用BIT

### 创建高性能的索引

索引（在MySQL中也叫做“键”）是存储引擎用于快速找到记录的一种数据机构。

#### 索引基础

在MySQL中，存储引擎用类似的方法使用索引，其先在索引中找到对应值，然后根据匹配的索引记录找到对应的数据行。

假设要运行下面的查询

```sql
mysql>select first_name from sakila.actor where actor_id = 5;
```

如果在actor_id列上建有索引，则MySQL将使用该索引找到actor_id为5的行，也就是说，MySQL先在索引上按值进行查找，然后返回所有包含该值的数据行。

索引可以包含一个或多个列的值。如果索引包含多个列，那么列的顺序也十分重要，因为MySQL只能高效地使用索引的最左前缀列。创建一个包含两个列的索引，和创建两个只包含一列的索引是大不相同的。

##### 索引的类型

在MySQL中，索引是在存储引擎层而不是服务器层实现的。所以，并没有统一的索引标准：不同存储引擎的索引的工作方式并不一样，也不是所有的存储引擎都支持所有类型的索引。即使多个存储引擎支持同一种类型的索引，其底层的实现也可能不同。

###### B-Tree索引

如果没有特别指明索引类型，多半说的是B-Tree索引，它使用B-Tree数据结构来存储数据。大多数MySQL引擎都支持这种索引。**底层的存储引擎也可能使用不同的存储结构，例如，NDB集群存储引擎内部实际上使用了T-Tree结构存储这种索引，InnoDB则使用的是B+Tree**

存储引擎以不同的方式使用B-Tree索引，性能也各有不同，各有优劣。**MyISAM使用前缀压缩技术使得索引更小，但InnoDB则按照原数据格式进行存储。再如MyISAM索引通过数据的物理位置引用被索引的行，而InnoDB则根据主键引用被索引的行。**

B-Tree索引能够加快访问数据的速度，因为存储引擎不再需要进行全表扫描来获取需要的数据，取而代之的是从索引的根节点开始进行搜索。

B-Tree对索引列是顺序组织存储的，所以很适合查找范围数据。例如，在一个基于文本域的索引数上，按字母顺序传递连续的值进行查找是非常合适的，所以像“找出所有以I到K开头的名字”这样的查找效率会非常高。

**可以使用B-Tree索引的查询类型**。B-TREE索引适用于**全键值，键值范围或键前缀**查找。其中键前缀查找只适用于根据最左前缀的查找。前面所述的索引对如下类型的查询有效。

*全值匹配*

全值匹配指的是和索引中所有列进行匹配，例如前面提到的索引可用于查找姓名为Cuba Allen,出生于1960-01-01的人。

*匹配最左前缀*

前面提到的索引可用于查找所有姓为Allen的人，即只使用索引的第一列。

*匹配列前缀*

也可以只匹配某一列的值的开头部分。例如前面提到的索引可用于查找所有以J开头的姓的人。这里也只使用了索引的第一列。

*匹配范围值*

例如前面提到的索引可用于查找姓在Allen和Barrymore之间的人。这里也只使用了索引的第一列。

*精确匹配某一列并范围匹配另外一列*

前面提到的索引也可用于查找所有姓为Allen,并且名字是字母K开头（比如Kim,Karl等）的人，即第一列last_name全匹配，第二列first_name范围匹配。

*只访问索引的查询*

B-Tree通常可以支持“只访问索引的查询”，即查询只需要访问索引，而无须访问数据行。后面我们讲单独讨论这种"覆盖索引"的优化。

因为索引树中的节点是有序的，所以除了按值查找之外，索引还可以用于查询中的ORDER BY操作（按顺序查找）。一般来说，如果B-Tree可以按照某种方式查找到值，那么也可以按照这种方式用于排序。所以，如果ORDER BY子句满足前面列出的几种查询类型，则这个索引也可以满足对应的排序需求。

**下面是一些关于B-Tree索引的限制**

1. 如果不是按照索引的最左列开始查找，则无法使用索引。例如上面例子中的索引无法用于查找名字为Bill的人，也无法查找某个特定生日的人。因为这两列都不是最左列数据列。类似地，也无法查找姓氏以某个字母结尾的人。
2. 不能跳过索引中的列，也就是说，前面所述的索引无法用于查找姓为Smith并且在某个特定日期出生的人。如果不指定名（first_name），则MySQL只能使用索引的第一列。
3. 如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找。例如有查询WHERE last_name='Smith' AND first_name LIKE ‘J%’ AND dob = '1976-12-23',这个查询只能使用索引的前两个列，因为这里的LIKE是一个范围条件。

**这些限制都和索引列的顺序有关，在优化性能的时候，可能需要使用相同的列但顺序不同的索引来满足不同类型的查询需求**

###### 哈希索引

哈希索引基于哈希表实现，只有精确匹配索引所有列的查询才有效。对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码（hash code），哈希码是一个较小的值，并且不同的键值计算出来的哈希码也不一样。哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。

在MySQL中，只有Memory引擎显示支持哈希索引，这也是Memory引擎表的默认索引类型，Memory引擎同时也支持B-Tree索引。值得一提的是，**Memory引擎是支持非唯一哈希索引的，这在数据库世界里是比较与众不同的。如果多个列的哈希值相同，索引会以链表的方式存放多个记录指针到同一个哈希条目中。**

因为索引自身只需存储对应的哈希值，所以索引的结构十分紧凑，这也让哈希索引查找的速度非常快。然而，哈希索引也有它的限制：

1. 哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行。不过，访问内存中的行的速度很快。
2. 哈希索引数据并不是按照索引值顺序存储的，所以也就无法用于排序
3. 哈西索引也不支持部分索引列匹配查找，因为哈希索引始终是使用索引列的全部内容来计算哈希值的。例如，在数据列（A,B）上建立哈希索引，如果查询只有数据列A，则无法使用该索引。
4. 哈希索引只支持等值比较查询，也不支持任何范围查询，例如Where price>100。
5. 访问哈希索引的数据非常快，除非又很多哈希冲突（不同的索引列值却又相同的哈希值，当出现哈希冲突的时候，存储引擎必须遍历链表中所有的行指针，逐行进行比较，直到找到所有符合条件的行）
6. 如果哈希冲突很多的话，一些索引维护操作的代价也会很高。

*NDB集群引擎也支持唯一哈希索引，且在NDB集群引擎中作用非常特殊，但不属于本书的范围*

InnoDB引擎有一个特殊的功能叫做“自适应哈希索引”。当InnoDB注意到某些索引值被使用的非常频繁时，它会在内存中基于B-Tree索引之上再创建一个哈希索引，这样就让B-Tree索引也具体哈希索引的一些优点，比如快速的哈希查找。这是一个完全自动的，内部的行为，用户无法控制或者配置，不过如果有必要，完全可以关闭该功能。

**创建自定义哈希索引**
如果存储引擎不支持哈希索引，则可以模拟像InnoDB一样创建哈希索引，这可以享受一些哈希索引的遍历，例如只需很小的索引就可以为超长的键创建索引。

**使用CRC做哈希，记住不要使用SHA1()和MD5作为哈希函数，因为这两个函数计算出来的哈希值是非常长的字符串，会**

**浪费大量空间，比较时也会更慢。SHA1()和MD5()是强加密函数，设计目标是最大限度消除冲突，但这里并不需要这样高的要求。简单哈希函数的冲突在一个可以接受的范围，同时又能够提供更好的性能**

如果数据表非常大，CRC32()会出现大量的哈希冲突，则可以考虑自己实现一个简单的64位哈希函数。这个自定义函数要返回整数，而不是字符串。一个简单的办法可以使用MD5()函数返回值的一部分来作为自定义哈希函数。这可能比自己写一个哈希算法的性能要差。

**处理哈希冲突**。当使用哈希索引进行查询的时候，必须在WHERE子句中包含常量值：

```sql
mysql>SELECT id from url where url_crc=CRC32("http://www.mysql.com") and url="http://www.mysql.com"
```

一旦出现哈希冲突，另一个字符串的哈希值也恰好是1560514994，则下面的查询是无法正确工作的。

```sql
mysql>SELECT id from url where url_crc=CRC32("http://www.mysql.com");
```

要避免冲突问题，必须在WHERE条件中带入哈希值和对应列值。如果不是想查询具体值，例如只是统计记录数(不精确的)，则可以不带入列值，直接使用CRC32()的哈希值查询即可。

###### 空间数据索引

MyISAM表支持空间索引，可以用作地理数据存储。和B-Tree索引不同，这类索引无须前缀查询。空间索引会从所有维度来索引数据。查询时，可以有效地使用任意维度来组合查询。必须使用MySQL的GIS相关函数如MBRCONTAINTS()等来维护数据。

###### 全文索引

全文索引是一种特殊类型的索引，它查找的是文本中的关键词，而不是直接比较索引中的值，全文搜索和其他几类索引的匹配方式完全不一样。它有许多需要注意的细节，如停用词，词干和复数,布尔搜索等。全文索引更类似于搜索引擎做的事情，而不是简单的WHERE条件匹配。

**在相同的列上同时创建全文索引和基于值的B-Tree索引不会有冲突，全文索引适用于Match AGAINST操作，而不是普通的WHERE条件操作**

#### 索引的优点

索引可以让服务器快速地定位到表的指定位置。*这不是索引的唯一作用，到目前为止可以看到，根据创建的索引的数据结构不同，索引也有一些其他的附加作用*

最常见的B-Tree索引，按照顺序存储数据，所以MySQL可以用来做ORDER BY和GROUP BY操作。因为数据是有序的，所以B-Tree也就会将相关的列值都存储在一起。最后因为索引中存储了实际的列值，所以某些查询只使用索引就能够完全全部查询。据此特性，总结下来索引又如下三个优点：

1. 索引大大减少了服务器需要扫描的数据量
2. 索引可以帮助服务器避免排序和临时表
3. 索引可以将随机I/O变为顺序I/O

**索引是最好的解决方案吗**

索引并不总是最好的工具。总的来说，只有当索引帮助存储引擎快速查找到记录带来的好处大于其带来的额外工作时，索引才是有效的。对于非常小的表，大部分情况下简单的全表扫描更高效，对于中到大型的表，索引就非常有效。但对于特大型的表，建立和使用索引的代价将随之增长。这种情况下，则需要一种技术可以直接区分出查询需要的一组数据，而不是一条记录一条地匹配。例如可以使用分区技术。

**如果表的数量特别多，可以建立一个元数据信息表，用来查询需要用到的某些特性。**

#### 高性能的索引策略

##### 独立的列

我们通常会看到一些查询不当地使用索引，或者使得MySQL无法使用已有的索引。如果查询中的列不是独立的，则MySQL就不会使用索引。**独立的列是指索引列不能是表达式的一部分，也不能是函数的参数**

例如，下面这个查询无法使用actor_id列的索引

```mysql
mysql>select actor_id from sakila.actor where actor_id + 1 =5;
```

肉眼很容易看出where中表达式其实等价于actor_id = 4，但是MySQL无法自动解析这个方程式。这完全是用户行为。我们应该养成简化where条件的习惯，始终讲索引列单独放在比较符号的一侧。

下面是另一个常见的错误：

```sql
mysql>select ... where TO_DAYS(CURRENT_DATE)-TO_DAYS(date_col) <=10;
```

##### 前缀索引和索引选择性

有时候需要索引很长的字符列，这会让索引变得大且慢。一个策略是前面提到过的模拟哈希索引，但有时候这样做还不够，还可以做些什么呢？

**通常可以索引开始的部分字符，这样可以大大节约索引空间，从而提高索引效率。但这样也会降低索引的选择性。**索引的选择性是指，不重复的索引值（也称为基数）和数据表的记录总数（#T）的比值，范围从1/#T到1之间。索引的选择性越高则查询效率越高，因为选择性高的索引可以让MySQL在查找时过滤掉更多的行。唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。

**一般情况下某个列前缀的选择性也是足够高的，足以满足查询性能。**对于BLOB,TEXT或者很长的VARCHAR类型的列，必须使用前缀索引，因为MySQL不允许索引这些列的完整长度。

**诀窍在于要选择足够长的前缀以保证较高的选择性，同时又不能太长（以遍节约空间）.**前缀应该足够长，以使得前缀索引的选择性接近于整个列。

**前缀索引是一种能使索引更小，更快的有效办法，但另一个方面也有其缺点：MySQL无法使用前缀索引做ORDER BY 和GROUP BY，也无法使用前缀索引做覆盖扫描**

##### 多列索引

很多人对多列索引的理解都不够。一个常见的错误就是，为每个列创建独立的索引，或者按照错误的顺序创建多列索引。

先来看看第一个问题，为每个列创建独立的索引

```sql
create table t(c1 INT, c2 INT, C3 INT, key(c1),key(c2),key(c3));
```

这种索引策略，一般是由于人们听到一些专家诸如“把where条件里面的列都建上索引”这种模糊的建议导致的。实际上找个建议是非常错误的。这样一来最好的情况下也只能是“一星”索引。其性能比起真正的最优的索引可能差几个数量级。

在多个列上建立独立的单列索引大部分情况下并不能提高MySQL的查询性能。MySQL5.0和更新版本引入了一种叫做“索引合并”的策略，一定程度上可以使用表上的多个单列索引来定位指定的行。更早版本的MySQL只能使用其中某一个单列索引，然后这种情况没有哪一个独立的单列索引是非常有效的。

**索引合并策略有时候是一种优化的结果，蛋实际上更多时候说明了表上的索引建的很糟糕**

1. 当出现服务器对多个索引做相交操作时（通常有多个AND条件），通常意味着需要一个包含所有相关列的多列索引，而不是多个独立的单列索引。
2. 当服务器需要对多个索引做联合操作时（通常有多个OR条件），通常需要耗费大量CPU和内存资源在算法的缓存,排序和合并操作上。特别是当其中有些索引的选择性不高，需要合并扫描返回的大量数据的时候。
3. 更重要的是，优化器不会把这些计算到“查询成本”（cost）中，优化器只关心随机页面读取。这会使得查询的成本被“低估”，导致该执行计划还不如直接走全表扫描。这样做不但会消费更多的CPU和内存资源，还可能会影响查询的并发性，但如果是单独运行这样的查询则往往会忽略对并发性的影响。

**如果在EXPLAIN中看到又索引合并，应该好好检查一下查询和表的结构，看是不是已经是最优的，也可以通过参数optimizer_switch来关闭索引合并功能，也可以使用IGNORE INDEX提示让优化器忽略掉某些索引**

##### 选择合适的索引列顺序

正确的索引顺序依赖于使用该索引的查询，并且同时需要考虑如何更好地满足排序和分组的需要。在一个多列B-Tree索引中，索引列的顺序意味着索引首先按照最左列进行排序，其次是第二列，等等。所以，索引可以按照升序或者降序进行扫描，以满足精确符合列顺序的ORDER BY,GROUP BY和DISTINCT等子句的查询需求。

对于如何选择索引列的列顺序有一个经验法则：将选择性最高的列放到索引最前列。这个建议有用吗？在某些场景可能有帮助，但通常不如避免随机IO和排序那么重要，考虑问题需要更全面。

当不需要考虑排序和分组时，将选择性最高的列放在前面通常是很好的。这时候索引的作用只是用于优化WHERE条件的查找。在这种情况下，这样设计的索引确实能够最快地过滤出需要的行，对于在WHERE子句中只使用了索引部分前缀列的查询来说选择性也更高。然而，性能不只是依赖于所有索引列的选择性（整体基数），也和查询条件的具体值有关，也就是和值的分布有关。

以下面的查询为例：

```sql
select * from payment where staff_id = 2 and customer_id = 584;
```

是应该创建一个（staff_id, customer_id）索引还是应该颠倒一下顺序？

```sql
mysql>select sum(staff_id = 2) sum(customer_id = 584) from payment;
--SUM(staff_id=2):7992
--SUM(customer_id=584):30
```

根据前面的经验法则，应该将索引列customer_id放在前面，因为对应条件值的customer_id数量更小。**这样做有一个地方需要注意，查询的结果非常依赖于选定的具体值。如果按上述办法优化，可能对其他一些条件值的查询不公平，服务器的整体性能可能变得更糟，或者其他某些查询的运行变得不如预期。**

**经验法则考虑的是全局基数和选择性，而不是某个具体的查询**

```mysql
select count(distinct staff_id)/count(*) as staff_id_selectivity,count(distinct customer_id)/count(*) as customer_id_selectivity,count(*) from payment;
-- satff_id_selectivity:0.0001
-- customer_id_selectivity:0.0373
-- count(*):16049
```

customer_id的选择性更高，所以答案是将其作为索引列的第一列：

```mysql
mysql>alter table payment add key(customer_id,staff_id);
```

##### 聚簇索引

聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。但InnoDB的聚簇索引实际上在同一个结构中保存了B-Tree索引和数据行。

当表又聚簇索引时，它的数据行实际上存放在索引的叶子页中。术语"聚簇"表示数据行和相邻的键值紧凑地存储在一起。**因为无法同时把数据行存放在两个不同的地方所以一个表只能有一个聚簇索引。**(不过，覆盖索引可以模拟多个聚簇索引的情况)

**因为是存储引擎负责实现索引，因此不是所有的存储引擎都支持聚簇索引。**

###### 一些数据库服务器允许选择哪个索引作为聚簇索引，但直到本书写作之际，还没有任何一个MYSQL内置的存储引擎支持这一点。InnoDB将通过主键聚集数据。

**如果没有定义主键，InnoDB会选择一个唯一的非空索引代替。如果没有这样的索引，InnoDB会隐式定义一个主键来作为聚簇索引。InnoDB只聚集在同一个页面中的记录。包含相邻键值的页面可能相距甚远。**

###### 聚集的数据有一些重要的优点

1. 可以把相关数据保存在一起。例如实现电子邮箱时，可以根据用户ID来聚集数据，这样只需要从磁盘读取少数的数据页就能获取某个用户的全部邮件。如果没有使用聚簇索引，则每封邮件都可能导致一次磁盘i/o
2. 数据访问更快。聚簇索引将索引和数据保存在同一个B-Tree中，因此从聚簇索引中获取数据通常比在非聚簇索引中查找更快
3. 使用覆盖索引扫描的查询可以直接使用页结点中的主键值

###### 如果在设计表和查询时能充分利用上面的优点，那就能极大的提升性能。同时，聚簇索引也有一些缺点

1. 聚簇索引最大限度地提高了I/O密集型应用的性能，但如果数据全部都放在内存中，则访问的顺序就没那么重要了，聚簇索引也就没什么优势了。
2. 插入速度严重依赖于插入顺序。按照主键的顺序插入是加载数据到InnoDB表中速度最快的方式。但如果不是按照主键顺序加载数据，那么在加载完成后最好使用OPTIMIZE TABLE命令重新组织一下表
3. 更新聚簇索引列的代价很高，因为会强制InnoDB将每个被更新的行移动到新的位置
4. 基于聚簇索引的表在插入新行，或者主键被更新导致需要移动行的时候，可以面临"页分裂"的问题。当行的主键值要求必须将这一行插入到某个已满的页中时，存储引擎会将该页分裂成两个页面来容纳该行，这就是一次页分裂操作。页分裂会导致表占用更多的磁盘空间
5. 聚簇索引可能导致全表扫描变慢，尤其是行比较稀疏，或者由于页分裂导致数据存储不连续的时候。
6. 二级索引(非聚簇索引)可能比想象的要更大，因为在二级索引的叶子节点包含了引用行的主键列。
7. 二级索引访问需要两次索引查找，而不是一次。

**为什么二级索引需要两次索引查找？答案在于二级索引中保存的"行指针"的实质，要记住，二级索引叶子节点保存的不是指向行的物理位置的指针，而是行的主键值。**

这意味着通过二级索引查找行，存储引擎需要找到二级索引的叶子节点获得对应的主键值，然后根据这个值去聚簇索引中查找到对应的行。这里做了重复的工作：两次B-Tree查找而不是一次。

###### 在InnoDB中，聚簇索引“就是”表，所以不像MyISAM那样需要独立的行存储。聚簇索引的每一个叶子节点都包含了主键值,事务ID，用于事务和MVCC的回滚以及所有的剩余列。如果主键是一个列前缀索引，InnoDB也会包含完整的主键列和剩下的其他列。

##### 在InnoDB表中按主键顺序插入行

如果正在使用InnoDB表并且没有什么数据需要聚集，那么可以定义一个代理键作为主键，这种主键的数据应该和应用无关，最简单的方法是使用AUTO_INCREMENT自增列。这样可以保证数据行是按顺序写入，对于根据主键做关联操作的性能也会更好。

**最好避免随机的（不连续且值的分布范围非常大）聚簇索引，特别是对于I/0密集型的应用。**

##### 覆盖索引

索引确实是一种查找数据的高效方式，但是MySQL可可以使用索引来直接获取列的数据，这样就不再需要读取数据行。如果索引的叶子节点中已经包含要查询的数据，那么还有什么必要再回表查询呢?**如果一个索引包含(或者说覆盖)所有需要查询的字段的值，我么就称之为"覆盖索引"。**

###### 在大多数存储引擎中，覆盖索引只能覆盖那些只访问索引中部分列的查询。不过，可以更进一步优化I你弄DB。回想一下InnoDB的二级索引的叶子节点都包括了主键的值，这意味着InnoDB的二级索引可以有效地利用这些“额外”的主键值来覆盖查询。

##### 使用索引扫描来做排序

MySQL有两种方式可以生成有序的结果：通过排序操作；或者按索引顺序扫描；如果EXPLAIN出来的type列的值为''index"，则说明MySQL使用了索引扫描来做排序

扫描索引本身是很快的，因为只需要从一条记录移动到紧接着的下一条记录。但如果索引不能覆盖查询所需的全部列，那就不得不扫描一条索引记录就都回表查询一次对应的行。这基本上都是随机I/O，因此按索引顺序读取数据的速度通常要比顺序地全表扫描慢，尤其是在I/O密集型的工作负载时。

只有当索引的列顺序和ORDER BY子句的顺序完全一致，并且所有列的排序方向（倒序或正序）都一样时，MySQL才能够使用索引来对结果做排序。如果查询需要关联多张表，则只有当Order By子句引用的字段全部为第一个表时，才能使用索引做排序

##### 压缩（前缀压缩）索引

MyISAM使用前缀压缩来减少索引的大小，从而让更多的索引可以放入内存中，这在某些情况下能极大地提升性能。默认只压缩字符串，但通过参数设置也可以对整数做压缩。

MyISAM压缩每个索引块的方法是，先完全保存索引块中的第一个值，然后将其他值和第一个值进行比较得到相同前缀的字节数和剩余的不同后缀部分，把这部分存储起来即可。例如，索引块中的第一个值是“perform”，第二个值是“performance”,那么第二个值的前缀压缩后存储的是类似“7，ance”这样的形式。MyISAM对行指针也采用类似的前缀压缩方式。

**压缩块使用更少的空间，代价是某些操作可能更慢。因为每个值的压缩前缀都依赖前面的值，所以MyISAM查找时无法在索引快使用二分查找而只能从头开始扫描。正序的扫描速度还不错，但是如果是倒序扫描就不是很好了。**

**压缩索引需要在CPU内存资源与磁盘之间做权衡。压缩索引可能只需要十分之一大小的磁盘空间，如果是I/O密集型应用，对某些查询带来的好处是会比成本多很多**

##### 冗余和重复索引

MySQL允许在相同列上创建多个索引，无论是有意的还是无意的。MySQL需要单独维护重复的索引，并且优化器在优化查询的时候也需要逐个地进行考虑，这会影响性能。

重复索引是指在相同的列上按照相同的顺序创建的相同类型的索引。应该避免这样创建重复索引，发现以后也应该立即移除。

有时会在不经意间创建了重复的索引，例如下面的代码

```sql
create table test(
ID INT NOT NULL PRIMARY KEY,
A INT NOT NULL,
B INT NOT NULL,
UNIQUE(ID),
INDEX(ID)
)ENGINE = InnoDB;
```

**一个经验不足的用户可能是想创建一个主键，先加上唯一限制，然后再加上索引以供查询使用。事实上，MySQL的唯一限制和主键限制都是通过索引来实现的，因此，上面的写法实际上在相同的列上创建了三个重复的索引。通常并没有理由这样做，除非实在同一列上创建不同类型的索引来满足不同的查询需求。**

###### 冗余索引和重复索引有一些不同。如果创建了索引（A，B），在创建索引（A）就是冗余索引，因为这只是前一个索引的前缀索引。因此索引（A，B）也可以当作索引(A)来使用（这种索引只是对B-Tree索引来说的）。但是如果再创建索引（B,A），则不是冗余索引，索引（B）也不是，因为B不是索引（A,B）的最左前缀列。另外，其他不同类型的索引（例如哈希索引或者全文索引）也不会是B-Tree索引的冗余索引，而无论覆盖的索引列是什么。

**冗余索引通常发生在为表添加新索引的时候。例如，有人可能会增加一个新的索引（A,B）而不是扩展已有的索引（A）。还有一种情况是将一个索引扩展为（A，ID），其中ID是主键，对于InnoDB来说主键列已经包含在二级索引中了，所以这也是冗余的**

###### 表中的索引越多插入速度会越慢。一般来说，增加新索引将会导致INSERT,UPDATE,DELETE等操作的速度变慢，特别是当新增索引后导致达到了内存瓶颈的时候。

##### 未使用的索引

除了冗余索引和重复索引，可能还会有一些服务器永远不用的索引。这样的索引完全是累赘，建议考虑删除。

##### 索引和锁

索引可以让查询锁定更少的行。如果你的查询从不访问那些不需要的行，那么就会锁定更少的行，从两个方面来看这对性能都有好处。首先，虽然InnoDB的行锁效率很高，内存使用也很少，但是锁定行的时候仍然会带来额外开销；其次，锁定超过需要的行会增加锁争用并减少并发性

**InnoDB只有在访问行的时候才会对其加锁，而索引能够减少InnoDB访问的行数，从而减少锁的数量。但这只有当InnoDB在存储引擎层能够过滤掉所有不需要的行时才有效。如果索引无法过滤掉无效的行。那么在InnoDB检索到数据并返回给服务器层以后MySQL服务器才能应用where子句。这时已经无法避免锁定行了：InnoDB已经锁住了这些行。到适当的时候才释放。在MySQL5.1和更新版本中，InnoDB可以在服务器端过滤掉行后几释放锁。但是在早期的MySQL版本中，InnoDB只有在事物提交后才能释放锁。**

##### 减少索引和数据的碎片

B-Tree索引可能会碎片化，这会降低查询的效率，碎片化的索引可能会以很差或者无序的方式存储在磁盘上。

**表的数据存储也可能碎片化。然而，数据存储的碎片化比索引更加复杂。有三种类型的数据碎片**

1. **行碎片** 这种碎片指的是数据行被存储在多个地方的多个片段中。即使查询只从索引中访问一行记录，行碎片也会导致性能下降
2. **行间碎片** 行间碎片是指逻辑上顺序的页，或者行在磁盘上不是顺序存储的。行间碎片对诸如全表扫描和聚簇索引扫描之类的操作有很大的影响，因为这些操作原本能够从磁盘上顺序存储的数据中获益
3. **剩余空间碎片**  剩余空间碎片是指数据页中有大量的空余空间。这会导致服务器读取大量不需要的数据，从而造成浪费。

对于MyISAM表，这三类碎片化都可能发生。但InnoDB不会出现短小的行碎片；InnoDB会移动短小的行并重写到一个片段中。

### 查询性能优化

#### 慢查询基础：优化数据访问

查询性能低下最基本的原因是访问的数据太多。大部分性能地下的查询都可以通过减少访问的数据量的方式进行优化。对于低效的查询，我们发现通过下面两个步骤来分析总是很有效：

1. 确认应用程序是否在检索大量超过需要的数据。这通常意味着访问了太多的行，但有时候也可能是访问了太多的列。
2. 确认MySQL服务器层是否在分析大量超过需要的数据行。

##### 是否向数据库请求了不需要的数据

有些查询会请求超过实际需要的数据，然后这些多余的数据会被应用程序丢弃。这会给MySQL服务器带来额外的负担，并增加网络开销，另外也会消耗应用服务器的CPU和内存资源

##### MySQL是否在扫描额外的记录

在确定查询只返回需要的数据以后，接下来应该看看查询为了返回结果是否扫描了过多的数据。对于MySQL,最简单的衡量查询开销的三个指标如下：

1. 响应时间
2. 扫描的行数
3. 返回的行数

###### 响应时间

响应时间是两个部分之和：服务时间和排队时间。服务时间是指数据库处理这个查询真正花了多长时间。排队时间是指服务器因为等待某些资源而没有真正执行查询的时间--可能因为是等I/O操作完成，也可能是等待行锁。

###### 扫描的行数和返回的行数

分析查询时，查看该查询扫描的行数是非常有帮助的。这在一定程序上能够说明该查询找到需要的数据的效率不高。

对于找出那些“糟糕“的查询，这个指标可能还不够完美，因为并不是所有的行的访问代价都是相同的。较短的行的访问速度更快，内存中的行也比磁盘中的行的访问速度要快得多。

###### 扫描的行数和访问类型

在评估查询开销的时候，需要考虑一下从表中找到某一行数据的成本。MySQL有好几种访问方式可以查找并返回一行的结果。

在EXPLAIN语句中的type列反应了访问类型。访问类型又很多种，从全表扫描到索引扫描，范围扫描，唯一索引查询，常数引用等。

一般MySQL能够使用如下三种方式应用WHERE条件，从好到坏依次为：

1. 在索引中使用WHERE条件来过滤不匹配的记录。这是在存储引擎层完成的。
2. 使用索引覆盖扫描来返回记录，直接从索引中过滤不需要的记录的记录并返回命中的结果。这是在MySQL服务器层完成的，但无须再回表查询记录
3. 从数据表中返回数据，然后过滤不满足条件的记录。这在MySQL服务器层完成，MySQL需要先从数据表读出记录然后过滤。

#### 重构查询的方式

##### 一个复杂查询还是多个简单的查询

##### 切分查询

有时候对于一个大查询我们需要"分而治之"，将大查询切分成小查询，每个查询功能完全一样，只完成一小部分每次只返回一小部分查询结果。

删除旧的数据就是一个很好的例子。定期地清除大量数据时，如果用一个大的语句一次性完成的话，则可能需要一次锁住很多数据，占满整个事务日志，耗尽系统资源，阻塞很多小的但重要的查询。将一个大的DELETE语句切分成多个较小的查询可以尽可能小地影响MySQL性能，同时还可以减少MySQL复制的延迟。

##### 分解关联查询

用分解关联查询的方式重构查询有如下的优势

1. 让缓存的效率更高。许多应用程序可以方便地缓存单表查询对应的结果对象。对MySQL的查询缓存来说，如果关联中的某个表发生了变化，那么就无法使用查询缓存了，而拆分后，如果某个表很少改变，那么基于该表的查询就可以重复利用查询缓存结果了。
2. 将查询分解后，执行单个查询可以减少锁的竞争
3. 在应用层做关联，可以更容器数据库进行拆分，更容易做到高性能和可扩展。
4. 查询本身效率也可能会有所提升。在这个例子中，使用IN()代替关联查询，可以让MySQL按照ID顺序进行查询，这可能比随机的关联要更高效。
5. 可以减少冗余记录的查询。在应用层做关联查询，意味着对于某条记录应用只需要查询一次，而在数据库中做关联查询，则可能需要重复地访问一部分数据。从这点看，这样的重构还可能会减少网络和内存的消耗。
6. 更进一步，这样做相当于在应用中实现了哈希关联，而不是使用MySQL的嵌套循环关联。某些场景哈希关联的效率要高很多

##### 查询执行的基础

###### 查询执行路径

1. 客户端发送一条查询给路由器
2. 服务器先检查查询缓存，如果命中了缓存，则立即返回存储在缓存中的结果。否则进入下一阶段。
3. 服务器端进行SQL解析，预处理，再由优化器生成对应的执行计划
4. MySQL根据优化器生成的执行计划，调用存储引擎的API来执行查询。
5. 将结果返回给客户端

##### MySQL客户端/服务器通信协议

一般来说，不需要去理解MySQL通信协议的内部实现细节，只需要大致理解通信协议是如何工作的。MySQL客户端和服务器之间的通信协议是"半双工"的，这意味着，在任何一个时刻，要么是由服务器向客户端发送数据，要么是由客户端向服务器发送数据。

**这种协议让MySQL通信简单快速，但是也从很多地方限制了MySQL。一个明显的限制是，这意味着没法进行流量控制。一旦一端开始发生消息，另一端要接收完整个 消息才能响应他。**

##### 查询状态

###### sleep

线程正在等待客户端发送新的请求

###### Query 

线程正在执行查询或者正在将结果发送给客户端

###### Locked

在MySQL服务器层，该线程正在等待表锁。在存储引擎级别实现的锁，例如InnoDB的行锁，并不会体现在线程状态中。对于MyISAM来说这是一个比较典型的状态，但在其他没有行锁的引擎中也经常会出现。

###### Analyzing and staticstics

线程正在收集存储引擎的统计信息，并生成查询的执行计划

###### Copying to tmp table

线程正在执行查询，并且将其结果集都复制到一个临时表中，这种状态一般要么是在做GROUP BY操作，要么是文件排序操作，或者是UNIOIN操作。如果这个状态后面还有"on disk"标记，那表示MySQL正在将一个内存临时表存放到磁盘上。

###### Sort result

县城正在对结果集进行排序

###### Sending data

这表示多种情况:线程可能在多个状态之间传递数据，或者在生成结果集，或者在像客户端返回数据

##### 查询缓存

在解析一个查询语句之前，如果查询缓存是打开的，那么MySQL会优先检查这个查询是否命中查询缓存中的数据。这个检查是通过一个对大小写敏感的哈希查找实现的。查询和缓存中的查询即使只有一个字节不同，那也不会匹配缓存结果，这种情况下查询就会进入下一阶段的处理。

如果当前的查询恰好命中了缓存，那么在查询结果之前MySQL会检查一次用户权限。如果权限没有问题，MySQL会跳过所有其他阶段，直接从缓存中拿到结果并返回给客户端。

###### 查询优化

下面是一些MySQL能够处理的优化类型

**重新定义关联表的顺序**

数据表的关联并不总是按照在查询中指定的顺序进行。决定关联的顺序是优化器很重要的一部分功能。

**将外连接转化为内连接**

并不是所有的OUTER JOIN语句都必须以外连接的方式执行，诸多因为，例如WHERE条件，库表结构都可能让外连接等价于一个内连接。MySQL能够识别这点并重写查询，让其可以调整关联顺序。

**预估并转化为常数表达式**

**覆盖索引扫描**

**子查询优化**

**提前终止查询**

**等值传播**

**列表IN()的比较**

在很多数据库系统中，IN()完全等同于多个OR条件的子句，因为这两者是完全等价的。在MySQL中这点是不成立的，MySQL将IN()列表中的数据先进行排序，然后通过二分查找的方式来确定列表中值是否满足条件，这是一个O（logn）复杂度的操作，等价地转换成OR查询的复杂度为O（n）,对于IN（）列表中有大量取值的时候，MySQL的处理速度将会更快。

#### 排序优化

无论如何排序都是一个成本很高的操作，所以从性能角度考虑，应尽可能避免排序或者尽可能避免对大量数据进行排序。

**当不能使用索引生成排序结果的时候，MySQL需要自己进行排序，如果数据量小则在内存中进行，如果数据量大则需要使用磁盘，不过MySQL将这个过程统一称为文件排序，即使完全是内存排序不需要任何磁盘文件时也是如此。**

如果需要排序的数据量小于“排序缓冲区”，MySQL使用内存进行"快速排序"操作。如果内存不够排序，那么MySQL会先将数据分块，对每个独立的块使用"快速排序"进行排序，并将各个块的排序结果存放在磁盘上，然后将各个排好序的块进行合并，最后返回排序结果。

##### MySQL有如下两种排序算法

###### 两次传输排序

**读取行指针和需要排序的字段，对其进行排序，然后再根据排序结果读取所需要的数据行。**

这需要进行两次数据传输，即需要从数据表中读取两次数据，第二次读取数据的时候，因为是读取排序列进行排序后的所有记录，这会产生大量的随机I/O,所以两次数据传输的成本非常高。

###### 单次传输排序

**先读取查询所需要的所有列，然后在根据给定列进行排序，最后直接返回排序结果。**

这个算法只在MySQL4.1和后续更新的版本才引入。因为不再需要从数据表中读取两次数据，对于I/O密集型的应用，这样做的效率高了很多。另外，相比两次传输排序，这个算法只需要一次顺序I/O读取所有的数据，而无须任何的随机I/O。

##### 返回结果给客户端

查询执行的最后一个阶段是将结果返回给客户端。即使查询不需要返回结果集给客户端，MySQL仍然会返回这个查询的一些信息，如该查询影响到的行数。

**如果查询可以被缓存，那么MySQL在这个阶段也会将结果存放到查询缓存中**

###### MySQL将结果返回客户端是一个增量，逐步返回的过程。例如，在关联操作中，一旦服务器处理完最后一个关联表，开始生成第一条结果时，MySQL就可以开始向客户端逐步返回结果集了。

**这样处理有两个好处：服务器端无须存储太多的结果，也就不会因为要返回太多结果儿消耗太多内存。另外，这样的处理也让MySQL客户端第一时间获得返回的结果**

##### UNION的限制

有时，MySQL无法将限制条件从外层"下推"到内层，这使得原本能够限制部分返回结果的条件无法应用到内层查询的优化上。

如果希望UNION的各个子句能够根据LIMIT只取部分结果集，或者希望能够先排好序再合并结果集的话，就需要在UNION的各个子句中分别使用这些子句。

##### 哈希关联

MySQL并不支持哈希关联--MySQL的所有关联都是嵌套循环关联。不过，可以通过建立一个哈希索引来曲线地实现哈希关联。如果使用的是Memory存储引擎，则索引都是哈希索引，所以关联的时候也类似于哈希关联。MariaDB已经实现了真正的哈希关联。

##### 松散索引扫描

由于历史原因，MySQL并不支持松散索引扫描，也就无法按照不连续的方式扫描一个索引。通常，MySQL的索引扫描需要定义一个起点和终点，即使需要的数据只是这段索引中很少数的几个，MySQL仍需要扫描这段索引中的每一个条目。

##### 在同一个表上查询和更新

MySQL不允许对同一张表同时进行查询和更新。

```mysql
UPDATE tb1 AS outer_tbl SET cnt = (select count(*) from tb1 AS inner_tb1 Where inner_tb1.type = outer_tbl.type);
```

可以通过使用生成表的形式来绕过上面的限制，因为MySQL只会把这个表当作一个临时表来处理。

```mysql
update tb1 INNER JOIN（SELECT type,count(*) AS cnt FROM tb1 GROUP BY type）AS der USING(type)
SET tb1.cnt = der.cnt;
```

##### 优化关联查询

1. 确保ON或者USING子句中的列上有索引。在创建索引的时候就要考虑到关联的顺序。当表A和表B用列c关联的时候，如果优化器的关联顺序就是B，A，那么就不需要在B表的对应列上建上索引。没有用到的索引只会带来额外的负担。一般来说，除非有其他的理由，否则只需要在关联顺序中的第二个表的相应列上创建索引。
2. 确保任何的GROUP BY和ORDER BY中的表达式只涉及到一个表中的列，这样MySQL才又可能使用索引来优化这个过程。
3. 当升级MySQL的时候需要注意：关联语法，运算符优先级等其他可能会发生变化的地方。因为以前是普通关联的地方可能会变成笛卡儿积，不同类型的关联可能会生成不同的结果等。

##### 优化子查询

关于子查询优化我们给出的最重要的优化建议就是尽可能使用关联查询代替，至少当前的MySQL版本需要这样。

##### 优化GROUP BY和DISTINCT

在很多场景下,MySQL都使用同样的办法优化这两种查询，事实上，MySQL优化器会在内部处理的时候相互转化这两类查询。它们都可以使用索引来优化，这也是最有效的优化办法。

##### 优化UNION查询

MySQL总是通过创建并填充临时表的方式来执行UNION查询。因此很多优化策略在UNION查询中都没法很好地使用。除非确实选哦服务器消除重复的行，否则就一定要使用UNION ALL,这一点很重要。如果没有ALL关键字，MySQL会给临时表加上DISTINCT选项，这会导致对整个临时表的数据做唯一性检查。这样的代价非常高。即使有ALL关键字,MySQL仍然会使用临时表存储结果。

### 应用层优化

#### 缓存

可以把缓存分成两大类：被动缓存和主动缓存，被动缓存除了存储和返回数据外不做任何事情。当从被动缓存请求一些内容时，要么可以得到结果，要么得到"结果不存在"。被动缓存的一个典型例子是memcached。相比之下，主动缓存会在访问未命中时做一些额外的工作。通常会将请求转发给应用的其他部分来生成请求结果，然后存储该结果并返回给应用。Squid缓存代理服务器就是一个主动缓存。

##### 应用层缓存

应用层缓存通常在同一台机器的内存中存储数据，或者通过网络存在另一台机器的内存中。

###### 本地缓存

这种缓存通常很小，只在进程处理请求期间存在于进程内存中。本地缓存可以有效地避免对某些资源的重复请求。这种类型的缓存技术并不复杂：通常只是应用代码中的一个变量或者哈希表

###### 本地共享内存缓存

这种缓存一般是中等大小（几个GB），快速，难以在多台机器间同步。

###### 分布式内存缓存

最常见的分布式内存缓存的例子是memcached。分布式缓存比本地共享内存缓存要大的多，增长也容易。分布式缓存比本地共享缓存的延时要高很多，所以最高效的使用方法是批量进行多个获取操作。

###### 磁盘上的缓存

磁盘是很慢的，所以缓存在磁盘上的最好是持久化对象，很难全部装进内存的对象，或者静态内容。

##### 缓存控制策略

缓存也有像反范式化数据库设计一样的问题：重复数据，也就是说有多个地方需要更新数据，所以需要想办法避免读到脏数据。

###### TTL（time to live,存活时间）

缓存对象存储时设置一个过期时间;可以通过清理进程在达到过期时间后删掉对象，或者先留着直到下次访问时再清理（清理后需要使用新的版本替换）。对于数据很少变更或者没有新数据的情况，这是最好的失效策略。

###### 显式失效

如果不能接受脏数据，那么进程子更新原始数据时需要同时使缓存失效。这种策略有两个变种：**写-失效和写-更新**。**写-失效策略很简单：只需要标记缓存数据已经过期（是否清理缓存数据是可选的）。** **写-更新策略需要多做一些工作，因为在更新数据时就需要替换掉缓存项。**

###### 读时失效

在更改旧数据时，为了避免要同时失效派生出来的脏数据，可以在缓存中保存一些信息，当从缓存中保存一些信息，当从缓存中读数据时可以利用这些信息判断数据是否已经失效。

**和显式失效策略相比，这样做有很大的优势：成本固定且可以分散在不同时间内，假设要失效一个有一百万缓存对象依赖的对象，如果采用写时失效，需要一次在缓存中失效一百万个对象，即使有高效的方法来找到这些对象，也可能需要很长的时间才能完成。如果采用读时失效，写操作可以立即完成，但后续这一百万对象的读操作可能会有略微的延迟。这样就把失效一百万对象的开销分散了，并且可以帮助避免出现负载冲高和延迟增大的峰值。**

**一种最简单的读时失效的方法是采用对象版本控制。在缓存中存储一个对象时，也可以存储对象所依赖的数据的当前版本号或者时间戳。不管什么时候更新依赖于用户的数据，都需要更新用户的版本号**











