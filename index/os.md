# 操作系统

<https://antfaiz5z.github.io/2019/07/30/apue/>

## 进程、线程、协程

## 同步与互斥

## IPC

## 虚拟内存：高端内存、伙伴、slab、vmalloc

## IO 模型

### EPOLL

## 死锁

### 死锁产生

互斥条件：一个资源每次只能被一个进程使用。

请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。

不剥夺条件: 进程已获得的资源，在末使用完之前，不能强行剥夺。

循环等待条件: 若干进程之间形成一种头尾相接的循环等待资源关系。

### 死锁检测

银行家算法

### 死锁恢复

1、 撤消进程即当发现死锁时，就撤消（夭折）一些处于死锁状态的进程，并收回它的占用的资源，以解除死锁，使其它进程能继续运行，或者在提供检查点（checkpoint）信息情况下回退（rolled back）到一个较早的状态。这里有一个开销问题，即撤消哪个（些）进程比较“划算”。

2、 挂起进程即当发现死锁时，挂起一些进程，抢占它们占用的资源，使得处于死锁之中的其它进程继续执行。待以后条件满足后，再恢复被挂起的进程。

### 死锁预防

1、每个进程必须一次性地请求它所需要的所有资源。若系统无法满足这一要求，则它不能执行。这是一种预分资源方法，它破坏了产生死锁的第三个必要条件。

2、一个已占有资源的进程若要再申请新资源，它必须先释放已占资源。若随后它还需要它们，则需要重新提出申请。换言之，一个进程在使用某资源过程中可以放弃该资源，从而破坏了产生死锁的第二个必要条件。

3、将系统中所有资源顺序编号，规定进程只能依次申请资源，这就是说，一个进程只有在前面的申请满足后，才能提出对其后面序号的资源的请求。这是一种有序使用资源法，它破坏了产生死锁的第四个必要条件。

### 死锁避免

## 内存栅栏

简单来说内存屏障（Memory Barrier，或内存栅栏，Memory Fence）就是从本地或工作内存（CPU寄存器、高速缓存-cache）到主存之间的拷贝动作。

在多线程并发过程中，仅当写操作线程先跨越内存栅栏而读线程后跨越内存栅栏的情况下，写操作线程所做的变更才对其他线程可见。

volatile不具备“互斥性”

volatile不能保证变量的“原子性”

## 零拷贝

mmap、sendfile、splice等

<https://www.jianshu.com/p/fad3339e3448>

## 互斥锁实现读写锁

<https://blog.csdn.net/tt_love9527/article/details/82107549>

<https://blog.csdn.net/TT_love9527/article/details/81987215>
